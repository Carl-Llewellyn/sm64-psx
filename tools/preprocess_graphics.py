import sys
import re
from enum import IntEnum

if len(sys.argv) < 3:
	print(f"usage: {sys.argv[0]} <input.c> <output.processed.c> [-DDEFINITION=VALUE...]")
	exit()

definitions: dict[str, int] = {}

for arg in sys.argv[3:]:
	if arg.startswith("-D"):
		if (eq_idx := arg.find("=")) != -1:
			def_name = arg[2:eq_idx]
			definitions[def_name] = int(arg[eq_idx + 1:])
		else:
			def_name = arg[2:eq_idx]
			definitions[def_name] = 0

definitions["BUGFIX_BOWSER_FADING_OUT"] = 1 if definitions.get("VERSION_US") or definitions.get("VERSION_EU") or definitions.get("VERSION_SH") else 0

out_lines: list[str] = ["// this file is generated by tools/preprocess_graphics.py, see the original file instead\n"]
display_lists: dict[str, "DisplayList"] = {}
display_lists_ordered: list[str] = []

# these cause a lot of glitches for some reason :( might be a bug in the rsp jit though
INLINE = False
INLINE_AGGRESSIVELY = False # inline a call even when there is more than one use

# section: definitions in object form

class Cmd:
	__slots__ = "name", "line", "between_parentheses"
	name: str
	line: str
	between_parentheses: str

	def __init__(self, line: str):
		self.line = line
		rparen_idx = line.rfind(")")
		assert rparen_idx >= len(line) - 2, line
		lparen_idx = line.find("(")
		self.name = line[0:lparen_idx]
		self.between_parentheses = self.line[lparen_idx + 1:rparen_idx]

	def get_args(self) -> list[str]:
		return self.between_parentheses.split(",")

class DisplayList:
	__slots__ = "use_count", "def_line", "name", "cmds"
	use_count: int
	def_line: str
	name: str
	cmds: list[Cmd]

	def __init__(self, def_line: str, name: str):
		self.use_count = 0
		self.def_line = def_line
		self.name = name
		self.cmds = []

	def try_inline(self):
		i = 0
		while i < len(self.cmds):
			cmd = self.cmds[i]
			if cmd.name == "gsSPDisplayList" and (target := display_lists.get(cmd.between_parentheses)):
				if INLINE_AGGRESSIVELY or target.use_count <= 1:
					self.cmds = [*self.cmds[:i], *target.cmds, *self.cmds[i + 1:]]
			i += 1

# section: parsing

class ParseState(IntEnum):
	TopLevel = 0
	CopiedDefinition = 1
	IgnoredDefinition = 2
	MultilineComment = 3
	VertexList = 4
	DisplayList = 5
	DisplayListEnded = 6

#def make_pointer_op(op: str, symbol: str, target_segment: int | None) -> str:
#	segment_in_name = None
#	try:
#		segment_in_name = int(symbol[-8:-6], 16)
#	except:
#		pass
#	if segment_in_name is not None:
#		target_segment = segment_in_name
#	elif target_segment is None:
#		if symbol.startswith("dAmp"):
#			target_segment = 0x08
#		elif symbol.startswith("dl_castle_aquarium_light") or symbol.startswith("dl_castle_lobby_wing_cap_light"):
#			target_segment = 0x07
#		else:
#			raise ValueError(f"could not determine segment of symbol '{symbol}'")
#	return f"(u32) (((void*) {symbol}) + ({op} << 24) - {target_segment << 24}),\n"

cur_display_list: DisplayList | None = None
triangle_queue: list[tuple[int, int, int] | None] = []

def flush_single_triangle(t0_idx: int):
	t0 = triangle_queue[t0_idx]
	if t0 is not None:
		for t1_idx in range(len(triangle_queue)):
			if t0_idx != t1_idx:
				t1 = triangle_queue[t1_idx]
				if t1 is not None:
					t0i0, t0i1, t0i2 = t0
					t1i0, t1i1, t1i2 = t1
					for t0_rotation in range(3):
						for t1_rotation in range(3):
							if t1i0 == t0i2 and t1i1 == t0i1:
								triangle_queue[t0_idx] = None
								triangle_queue[t1_idx] = None
								cur_display_list.cmds.append(Cmd(f"gsSPPortQuadrangle({t0i0}, {t0i1}, {t0i2}, {t1i2}),"))
								return
							t1i0, t1i1, t1i2 = t1i2, t1i0, t1i1
						t0i0, t0i1, t0i2 = t0i2, t0i0, t0i1

def flush_triangle_queue():
	for t0_idx in range(len(triangle_queue)):
		flush_single_triangle(t0_idx)
	last = None
	for t in triangle_queue:
		if t is not None:
			if last is None:
				last = t
			else:
				cur_display_list.cmds.append(Cmd(f"gsSP2Triangles({last[0]}, {last[1]}, {last[2]}, 0, {t[0]}, {t[1]}, {t[2]}, 0),"))
				last = None
	if last is not None:
		cur_display_list.cmds.append(Cmd(f"gsSP1Triangle({last[0]}, {last[1]}, {last[2]}, 0),"))
	triangle_queue.clear()

model_c_path = sys.argv[1]
with open(model_c_path, "r") as in_file:
	in_lines = in_file.readlines()

# quickly preprocess conditional directives by marking what lines should be excluded
line_should_be_excluded: list[bool] = []
exclusion_depth = 0
for line_idx, line in enumerate(in_lines):
	if (comment_idx := line.find("//")) != -1:
		line = line[:comment_idx]
	line: str = line.strip()
	should_exclude_line = exclusion_depth > 0
	if exclusion_depth > 0:
		if line.startswith("#else") and exclusion_depth == 1:
			exclusion_depth -= 1
		elif line.startswith("#elif") and exclusion_depth == 1:
			condition = line[6:].strip()
			if condition.isidentifier():
				if definitions[condition] != 0:
					exclusion_depth -= 1
			elif matches := re.match(r"defined\(([A-Za-z_0-9]+)\)(?: \|\| defined\(([A-Za-z_0-9]+)\))*", condition):
				for match in matches.groups():
					if match in definitions:
						exclusion_depth -= 1
						break
			else:
				raise RuntimeError(f"unhandled condition in {model_c_path}:{line_idx + 1}")
		elif line.startswith("#ifdef") or line.startswith("#ifndef") or line.startswith("#if"):
			exclusion_depth += 1
		elif line.startswith("#endif"):
			exclusion_depth -= 1
	elif line.startswith("#ifdef"):
		should_exclude_line = True
		name = line[7:].strip()
		assert name.isidentifier(), f"non identifier condition in {model_c_path}:{line_idx + 1}"
		if name not in definitions:
			exclusion_depth += 1
	elif line.startswith("#ifndef"):
		should_exclude_line = True
		name = line[8:].strip()
		assert name.isidentifier(), f"non identifier condition in {model_c_path}:{line_idx + 1}"
		if name in definitions:
			exclusion_depth += 1
	elif line.startswith("#if"):
		should_exclude_line = True
		condition = line[4:].strip()
		if condition.isidentifier():
			if definitions[condition] == 0:
				exclusion_depth += 1
		elif matches := re.match(r"defined\(([A-Za-z_0-9]+)\)(?: \|\| defined\(([A-Za-z_0-9]+)\))*", condition): # chain of defined(X)s ored together
			found_any = False
			for match in matches.groups():
				if match in definitions:
					found_any = True
					break
			if not found_any:
				exclusion_depth += 1
		else:
			raise RuntimeError(f"unhandled condition in {model_c_path}:{line_idx + 1}")
	elif line.startswith("#else") or line.startswith("#elif"):
		should_exclude_line = True
		exclusion_depth += 1
	elif line.startswith("#endif"):
		should_exclude_line = True
	line_should_be_excluded.append(should_exclude_line)
#assert len(exclusion_stack) == 0, f"unmatched conditional directive somewhere in {model_c_path}"

state = ParseState.TopLevel
cur_file_segment: int | None = None
cur_flags = "0"
for line_idx, line in enumerate(in_lines):
	if line_should_be_excluded[line_idx]:
		continue
	line: str = line.strip()
	if line.startswith("// 0x"):
		prev = cur_file_segment
		cur_file_segment = int(line[5:7], 16)
		assert prev is None or cur_file_segment == prev
		continue
	if len(line) == 0 or line.startswith("//"):
		continue
	if line.startswith("#") and state != ParseState.MultilineComment:
		out_lines.append(line + "\n")
		continue
	match state:
		case ParseState.TopLevel:
			elems = line.split(" ")
			if line.startswith("/*"):
				state = ParseState.MultilineComment
			elif elems[0] == "UNUSED":
				if not line.endswith(";"):
					state = ParseState.IgnoredDefinition
			else:
				is_static = False
				for i, e in enumerate(elems):
					match e:
						case "ALIGNED8" | "const":
							pass
						case "static":
							is_static = True
						case "Lights1" | "Movtex" | "f32" | "q32" | "Collision" | "Mtx" | "LevelScript" | "GeoLayout" | "struct" | "Vtx": # simply copy a definition over
							out_lines.append(line + "\n")
							state = ParseState.CopiedDefinition
							break
						case "Texture" | "u8": # no need for 8 bytes of alignment on psx
							out_lines.append(line.replace("ALIGNED8", "ALIGNED4") + "\n")
							state = ParseState.CopiedDefinition
							break
						#case "Vtx": # TODO
						#	name = elems[i + 1]
						#	assert name.endswith("[]")
						#	if is_static:
						#		out_lines.append(f"static const EitherVtx {name} = {{\n")
						#	else:
						#		out_lines.append(f"const EitherVtx {name} = {{\n")
						#	state = ParseState.VertexList
						#	break
						case "Gfx":
							name = elems[i + 1]
							assert name.endswith("[]")
							name = name[:-2]
							cur_display_list = DisplayList(line, name)
							state = ParseState.DisplayList
							cur_flags = "0"
							break
						case "s16":
							if is_static: # the only time this is used, it is unused
								state = ParseState.IgnoredDefinition
							else:
								out_lines.append(line + "\n")
								state = ParseState.CopiedDefinition
							break
						case _:
							raise ValueError(f"unhandled identifier {e} in {model_c_path}:{line_idx + 1}")
		case ParseState.CopiedDefinition:
			if line.startswith("};") or line.startswith(");"):
				state = ParseState.TopLevel
			out_lines.append(line + "\n")
		case ParseState.IgnoredDefinition:
			if line.startswith("};") or line.startswith(");"):
				state = ParseState.TopLevel
		case ParseState.MultilineComment:
			if line.endswith("*/"):
				state = ParseState.TopLevel
		case ParseState.VertexList:
			if line.startswith("};"):
				state = ParseState.TopLevel
				out_lines.append(line + "\n")
			else:
				assert line.startswith("{{{") and line.endswith("}}},")
				parts = line.replace(" ", "").replace("}", "").replace("{", "").split(",")
				x, y, z, _, u, v, r, g, b, a = tuple(int(parts[i], 0) for i in range(len(parts) - 1))
				rgb = r | g << 8 | b << 16
				out_lines.append(f"{{.tag=COMPILED_TAG,.psx={{.x={x},.y={y},.z={z},.u={min(max((u*0xffff>>21) + 64, 0), 255)},.v={min(max((v*0xffff>>21) + 64, 0), 255)},.color.as_u32={rgb}}}}},\n")
		case ParseState.DisplayList:
			if line.startswith("};"):
				raise ValueError(f"display list ended prematurely in {model_c_path}:{line_idx + 1}")
			else:
				if (comment_idx := line.find("//")) != -1:
					line = line[0:comment_idx].strip()
				cmd = Cmd(line)
				match cmd.name:
					case "gsSPEndDisplayList" | "gsSPBranchList":
						flush_triangle_queue()
						cur_display_list.cmds.append(cmd)
						state = ParseState.DisplayListEnded
					case "gsSP1Triangle":
						args = cmd.get_args()
						triangle_queue.append((int(args[0].strip()), int(args[1].strip()), int(args[2].strip())))
					case "gsSP2Triangles":
						args = cmd.get_args()
						triangle_queue.append((int(args[0].strip()), int(args[1].strip()), int(args[2].strip())))
						triangle_queue.append((int(args[4].strip()), int(args[5].strip()), int(args[6].strip())))
					case "gsDPSetTile":
						if "G_TX_RENDERTILE" in line:
							cur_display_list.cmds.append(cmd)
					case "gsSPDisplayList":
						if (target := display_lists.get(cmd.between_parentheses)):
							target.use_count += 1
						flush_triangle_queue()
						cur_display_list.cmds.append(cmd)
					case "gsSPVertex" | "gsSPSetGeometryMode" | "gsSPClearGeometryMode" | "gsDPSetCombineMode" | "gsDPSetTextureImage" | "gsDPLoadTextureTile" | "gsDPLoadTextureBlock" | "gsSPTextureRectangle" | "gsSPTexture" | "gsSPLight" | "gsSPNumLights" | "gsSPSetLights1" | "gsSPSetEnvColor":
						flush_triangle_queue()
						cur_display_list.cmds.append(cmd)
		case ParseState.DisplayListEnded:
			if line.startswith("};"):
				display_lists_ordered.append(cur_display_list.name)
				display_lists[cur_display_list.name] = cur_display_list
				cur_display_list = None
				state = ParseState.TopLevel
			else:
				raise ValueError(f"display list did not end when expected in {model_c_path}:{line_idx + 1}")

for name in display_lists_ordered:
	dl = display_lists[name]
	if INLINE:
		dl.try_inline()
	out_lines.append(dl.def_line + "\n")
	for cmd in dl.cmds:
		out_lines.append(cmd.line + "\n")
	out_lines.append("};\n")

out_path = sys.argv[2]
assert ".processed.c" in out_path, "ensure the output path is correct"
with open(out_path, "w") as out_file:
	out_file.writelines(out_lines)
